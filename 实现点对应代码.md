我会按你们“Web 演示 + 15 分钟汇报”的节奏，给出 **15 页左右**的 PPT 逐页文案（每页 3–6 行要点），并为每页配一段“可截图/可粘贴”的关键代码片段（用具体文件与行号定位）。接下来我先把协议、路由、VFS、缓存、备份、权限相关核心文件读出来，确保每页引用都准确。

[35 tools called]

### 第1页：封面（项目一句话）
- **题目**：基于自研文件系统的简化学术评审系统（C/S）
- **关键词**：统一协议、TCP 通信、VFS、LRU 缓存、备份/恢复
- **目标**：把评审业务数据“只落盘到自研 FS”，并支持并发访问与可观测性

```1:5:/Volumes/External/Code/OsFinalProject/README.md
# 操作系统课程大作业：简化学术评审系统（C++ Client-Server）

本项目参考《Operating Systems Practical Training Course Guide》要求，实现一个**基于文件系统的学术评审系统**的骨架代码，采用 **Client-Server 架构 + 自定义简单文件系统 + LRU 缓存 + TCP 通信**。

当前提交为**初始项目结构与可编译骨架代码**，并已经实现**统一命令协议与服务器端命令路由框架**，便于后续在此基础上逐步完善业务功能。
```

---

### 第2页：工程结构（模块分层）
- **common**：协议与类型
- **domain**：认证/会话、RBAC 权限、论文/评审模型
- **server**：ServerApp 路由 + VFS + TCP 服务端
- **client/web**：CLI 与 Web 演示（通过 gateway 转发）

```7:37:/Volumes/External/Code/OsFinalProject/README.md
## 目录结构

- `OsFinalProject/`
  - `CMakeLists.txt`：顶层 CMake 配置
  - `src/`
    - `common/`：公共类型与协议
      - `protocol.hpp`：客户端与服务器之间的消息与统一命令协议定义
    - `domain/`：业务领域模型与权限/认证
      - `permissions.hpp/.cpp`：基于角色的高层操作权限检查
      - `auth.hpp/.cpp`：认证与会话（Session）服务
    - `server/`
      - `server_app.hpp/.cpp`：服务器核心类，负责加载文件系统、解析并路由客户端命令
      - `filesystem/`：自定义文件系统骨架
      - `net/`：网络层实现（长度前缀 + 自定义消息协议）
    - `client/`
      - `cli.hpp/.cpp`：命令行客户端
```

---

### 第3页：Web 演示链路（HTTP → TCP → C++ Server）
- **浏览器**：调用 `/api/login`、`/api/command`
- **Gateway（Node）**：把命令封成 `CommandRequest`，按 4 字节长度前缀写入 TCP
- **C++ Server**：解包后走统一协议与路由

```80:117:/Volumes/External/Code/OsFinalProject/gateway/server.js
async function forwardCommand(command, sessionId) {
  const parsed = parseCommandLine(command);
  if (!parsed.name) {
    return { ok: false, error: 'Missing command' };
  }

  const cmdJson = {
    sessionId: sessionId ? String(sessionId) : null,
    cmd: parsed.name,
    args: parsed.args,
    rawArgs: parsed.rawArgs,
  };

  const reqEnvelope = { type: 'CommandRequest', payload: cmdJson };
  const raw = await sendTcpEnvelope(reqEnvelope);

  let respEnvelope;
  try {
    respEnvelope = JSON.parse(raw);
  } catch (e) {
    return { ok: false, error: 'Malformed response from TCP server (not JSON)' };
  }

  const payload = respEnvelope && respEnvelope.payload ? respEnvelope.payload : {};
  const isOk = !!(payload && payload.ok);
  // ...
}
```

---

### 第4页：协议封装（Message Envelope）
- **统一 envelope**：`{ type, payload }`
- **序列化/反序列化**：全程 JSON，错误统一为 `PARSE_ERROR`

```49:80:/Volumes/External/Code/OsFinalProject/src/common/protocol.hpp
struct Message
{
    MessageType type{};
    json        payload; // JSON 格式的 payload
};

// 传输层序列化：整个 envelope 为 JSON { "type": "...", "payload": {...} }
inline std::string serialize(const Message& msg)
{
    json envelope;
    envelope["type"] = messageTypeToString(msg.type);
    envelope["payload"] = msg.payload;
    return envelope.dump();
}

inline Message deserialize(const std::string& data)
{
    Message msg{};
    try
    {
        json envelope = json::parse(data);
        msg.type = stringToMessageType(envelope.value("type", "Error"));
        msg.payload = envelope.value("payload", json::object());
    }
    catch (const json::exception&)
    {
        msg.type = MessageType::Error;
        msg.payload = {{"ok", false}, {"error", {{"code", "PARSE_ERROR"}, {"message", "Failed to parse JSON message"}}}};
    }
    return msg;
}
```

---

### 第5页：命令抽象（Command + Session）
- **Command**：`name/args/rawArgs/sessionId`
- **sessionId 可为 null**：服务端解析时兼容 null/缺失

```89:145:/Volumes/External/Code/OsFinalProject/src/common/protocol.hpp
struct Command
{
    std::string              name;
    std::string              rawArgs;
    std::vector<std::string> args;
    std::string              sessionId; // 为空表示未携带 Session
};

inline Command parseCommandFromJson(const json& payload)
{
    Command cmd;
    if (payload.contains("sessionId") && payload["sessionId"].is_string())
    {
        cmd.sessionId = payload["sessionId"].get<std::string>();
    }
    cmd.name = payload.value("cmd", "");
    cmd.rawArgs = payload.value("rawArgs", "");

    if (payload.contains("args") && payload["args"].is_array())
    {
        for (const auto& arg : payload["args"])
        {
            if (arg.is_string())
            {
                cmd.args.push_back(arg.get<std::string>());
            }
        }
    }
    return cmd;
}
```

---

### 第6页：TCP 传输层（4 字节长度前缀）
- **Framing**：`[uint32_be length][json bytes]`
- **收益**：边界清晰、一次连接可多次请求（服务端循环读）

```58:91:/Volumes/External/Code/OsFinalProject/src/server/net/tcp_server.cpp
bool TcpServer::sendMessage(int fd, const osp::protocol::Message& msg)
{
    const std::string data = osp::protocol::serialize(msg);
    std::uint32_t len = static_cast<std::uint32_t>(data.size());
    len = htonl(len);
    if (!sendAll(fd, &len, sizeof(len)))
    {
        return false;
    }
    return sendAll(fd, data.data(), data.size());
}

std::optional<osp::protocol::Message> TcpServer::recvMessage(int fd)
{
    std::uint32_t len = 0;
    if (!recvAll(fd, &len, sizeof(len)))
    {
        return std::nullopt;
    }
    len = ntohl(len);
    if (len == 0)
    {
        return std::nullopt;
    }

    std::string data;
    data.resize(len);
    if (!recvAll(fd, data.data(), data.size()))
    {
        return std::nullopt;
    }

    return osp::protocol::deserialize(data);
}
```

---

### 第7页：Server 启动流程（挂载 FS + 初始化用户）
- **启动时挂载**：`vfs_.mount("data.fs")`
- **Auth 持久化**：从 VFS `loadUsers()`；为空则创建默认账号

```42:88:/Volumes/External/Code/OsFinalProject/src/server/server_app.cpp
void ServerApp::run()
{
    running_.store(true);
    // 挂载简化 VFS
    {
        std::lock_guard<std::mutex> lock(vfsMutex_);
        vfs_.mount("data.fs");
    }

    // 初始化 AuthService 的 VFS 操作接口
    initAuthVfsOperations();

    // 从 VFS 加载用户数据
    {
        std::lock_guard<std::mutex> authLock(authMutex_);
        auth_.loadUsers();

        // 如果没有用户数据，初始化默认账号
        if (auth_.getAllUsers().empty())
        {
            auth_.addUser("admin", "admin", osp::Role::Admin);
            auth_.addUser("author", "author", osp::Role::Author);
            auth_.addUser("author2", "author2", osp::Role::Author);
            auth_.addUser("reviewer", "reviewer", osp::Role::Reviewer);
            auth_.addUser("editor", "editor", osp::Role::Editor);
        }
    }

    // 使用多线程 TCP 服务器
    osp::net::TcpServer tcpServer(port_, threadPoolSize_);
    tcpServer.start([this](const osp::protocol::Message& req) {
        return handleRequest(req);
    });
}
```

---

### 第8页：统一入口（handleRequest：会话校验）
- **只接收 CommandRequest**
- **sessionId 非空则 validateSession**，失败统一返回 `INVALID_SESSION`

```137:172:/Volumes/External/Code/OsFinalProject/src/server/server_app.cpp
osp::protocol::Message ServerApp::handleRequest(const osp::protocol::Message& req)
{
    using osp::protocol::MessageType;
    using osp::protocol::Command;

    if (req.type != MessageType::CommandRequest)
    {
        return osp::protocol::makeErrorResponse("INVALID_TYPE", "Unsupported message type");
    }

    Command cmd = osp::protocol::parseCommandFromJson(req.payload);
    if (cmd.name.empty())
    {
        return osp::protocol::makeErrorResponse("EMPTY_COMMAND", "Empty command");
    }

    std::optional<osp::domain::Session> maybeSession;
    if (!cmd.sessionId.empty())
    {
        std::lock_guard<std::mutex> lock(authMutex_);
        auto s = auth_.validateSession(cmd.sessionId);
        if (!s)
        {
            return osp::protocol::makeErrorResponse("INVALID_SESSION", "Invalid or expired session");
        }
        maybeSession = *s;
    }

    return handleCommand(cmd, maybeSession);
}
```

---

### 第9页：路由解耦（ServerApp 只做分发）
- **先处理核心命令**：`PING/LOGIN`
- **再交给角色 handler**：Admin/Editor/Author/Reviewer
- **FS 命令**：最后由 `FsService` 处理

```174:224:/Volumes/External/Code/OsFinalProject/src/server/server_app.cpp
osp::protocol::Message ServerApp::handleCommand(const osp::protocol::Command& cmd,
                                                const std::optional<osp::domain::Session>& maybeSession)
{
    // PING
    if (cmd.name == "PING")
    {
        return osp::protocol::makeSuccessResponse({{"message", "PONG"}});
    }

    // LOGIN
    if (cmd.name == "LOGIN")
    {
        // ... verify args ...
        std::lock_guard<std::mutex> lock(authMutex_);
        auto session = auth_.login(cred);
        if (!session)
        {
            return osp::protocol::makeErrorResponse("LOGIN_FAILED", "LOGIN failed: invalid credentials");
        }
        // ... build session response ...
        return osp::protocol::makeSuccessResponse(data);
    }

    // 角色处理器：按职责拆分（处理器内部自行做权限检查）
    if (auto r = adminHandler_.tryHandle(cmd, maybeSession)) return *r;
    if (auto r = editorHandler_.tryHandle(cmd, maybeSession)) return *r;
    if (auto r = authorHandler_.tryHandle(cmd, maybeSession)) return *r;
    if (auto r = reviewerHandler_.tryHandle(cmd, maybeSession)) return *r;

    // FS 命令（不绑定角色）
    if (auto r = fsService_.tryHandle(cmd)) return *r;

    return osp::protocol::makeErrorResponse("UNKNOWN_COMMAND", "Unknown command: " + cmd.name);
}
```

---

### 第10页：权限模型（RBAC）
- **抽象 Permission**：上传、分配、终审、备份、状态查询等
- **hasPermission(role, permission)**：统一入口，业务命令按需调用

```6:53:/Volumes/External/Code/OsFinalProject/src/domain/permissions.cpp
bool hasPermission(Role role, Permission permission) noexcept
{
    using P = Permission;

    switch (role)
    {
    case Role::Author:
        switch (permission)
        {
        case P::UploadPaper:
        case P::SubmitRevision:
        case P::ViewOwnPaperStatus:
        case P::DownloadOwnReviews:
            return true;
        default:
            return false;
        }

    case Role::Editor:
        switch (permission)
        {
        case P::AssignReviewers:
        case P::MakeFinalDecision:
        case P::ViewSystemStatus:
            return true;
        default:
            return false;
        }

    case Role::Admin:
        return true;
    default:
        return false;
    }
}
```

---

### 第11页：业务数据如何落盘（以 /papers 为中心）
- **论文目录**：`/papers/<paperId>/meta.txt`
- **审稿人名单**：`/papers/<paperId>/reviewers.txt`
- **列表权限**：Author 只能看自己的；Reviewer 只能看分配给自己的

```189:266:/Volumes/External/Code/OsFinalProject/src/server/services/paper_service.cpp
while (std::getline(ss, entry))
{
    if (entry.empty() || entry.back() != '/')
    {
        continue;
    }

    std::string pidStr   = entry.substr(0, entry.size() - 1);
    std::string metaPath = "/papers/" + pidStr + "/meta.txt";

    std::optional<std::string> metaData;
    {
        std::lock_guard<std::mutex> lock(vfsMutex_);
        metaData = vfs_.readFile(metaPath);
    }
    if (!metaData)
    {
        continue;
    }

    // Author 只能看自己的
    if (isAuthor && p_authorId != maybeSession->userId)
    {
        continue;
    }

    // Reviewer 只能看分配给自己的
    if (isReviewer)
    {
        std::string reviewersPath = "/papers/" + pidStr + "/reviewers.txt";
        std::optional<std::string> reviewersData;
        {
            std::lock_guard<std::mutex> lock(vfsMutex_);
            reviewersData = vfs_.readFile(reviewersPath);
        }
        // ... check assigned ...
    }

    papers.push_back({{"id", p_id}, {"title", p_title}, {"status", p_status}, {"authorId", p_authorId}});
}
```

---

### 第12页：自动推荐审稿人（领域匹配）
- **论文领域**：`/papers/<id>/fields.txt`
- **审稿人领域**：`/system/reviewer_fields/<userId>.txt`
- **评分**：交集大小 `score`，排序取 topN

```94:121:/Volumes/External/Code/OsFinalProject/src/server/services/paper_service.cpp
std::vector<Candidate> candidates;
candidates.reserve(reviewers.size());

for (const auto& r : reviewers)
{
    std::set<std::string>      reviewerFieldSet;
    std::vector<std::string>   reviewerFields;
    {
        std::lock_guard<std::mutex> lock(vfsMutex_);
        vfs_.createDirectory("/system");
        vfs_.createDirectory("/system/reviewer_fields");
        const std::string path = "/system/reviewer_fields/" + std::to_string(r.userId) + ".txt";
        if (auto f = vfs_.readFile(path))
        {
            reviewerFields   = osp::server::utils::splitFieldsCsv(*f);
            reviewerFieldSet = osp::server::utils::toFieldSet(reviewerFields);
        }
    }

    auto matched = osp::server::utils::intersectionFields(paperFields, reviewerFieldSet);
    const std::size_t score = matched.size();
    candidates.push_back({r.username, r.userId, score, matched, reviewerFields});
}

std::sort(candidates.begin(), candidates.end(), [](const Candidate& a, const Candidate& b) {
    if (a.score != b.score) return a.score > b.score;
    return a.username < b.username;
});
```

---

### 第13页：自研文件系统布局（SuperBlock）
- **块划分**：superblock / inode table / free bitmap / data blocks
- **目的**：满足课程要求的“可解释布局”

```8:37:/Volumes/External/Code/OsFinalProject/src/server/filesystem/superblock.hpp
// 简化版 SuperBlock，描述磁盘上自定义文件系统的整体布局。
// 磁盘（backing file）按「块」划分：
// [0]             : superblock
// [inodeTableStart .. inodeTableStart + inodeTableBlocks - 1] : inode table
// [freeBitmapStart .. freeBitmapStart + freeBitmapBlocks - 1] : free data-block bitmap
// [dataBlockStart .. totalBlocks - 1]                         : data blocks
struct SuperBlock
{
    std::uint32_t magic{0x20251205};
    std::uint32_t blockSize{4096};
    std::uint32_t totalBlocks{0};

    std::uint32_t inodeTableStart{0};
    std::uint32_t inodeTableBlocks{0};
    std::uint32_t inodeCount{0};

    std::uint32_t freeBitmapStart{0};
    std::uint32_t freeBitmapBlocks{0};

    std::uint32_t dataBlockStart{0};
    std::uint32_t dataBlockCount{0};

    std::uint32_t rootInodeId{0};
};
```

---

### 第14页：格式化策略（固定布局，自动 mkfs）
- **magic 校验**：不是本 FS 就自动 format
- **常量布局**：4096B block、1024 blocks、inode 表 8 blocks、bitmap 1 block

```127:156:/Volumes/External/Code/OsFinalProject/src/server/filesystem/vfs.cpp
bool Vfs::formatNewFileSystem()
{
    // 设定一个固定大小的磁盘布局，满足课程中“有 superblock/inode 表/数据块区域/空闲位图”的要求。
    constexpr std::uint32_t kBlockSize = 4096;
    constexpr std::uint32_t kTotalBlocks = 1024;
    constexpr std::uint32_t kInodeTableBlocks = 8;
    constexpr std::uint32_t kFreeBitmapBlocks = 1;

    sb_.magic = kFsMagic;
    sb_.blockSize = kBlockSize;
    sb_.totalBlocks = kTotalBlocks;

    sb_.inodeTableStart = 1;
    sb_.inodeTableBlocks = kInodeTableBlocks;

    const std::uint32_t inodesPerBlock =
        sb_.blockSize / static_cast<std::uint32_t>(sizeof(Inode));
    sb_.inodeCount = inodesPerBlock * sb_.inodeTableBlocks;

    sb_.freeBitmapStart = sb_.inodeTableStart + sb_.inodeTableBlocks;
    sb_.freeBitmapBlocks = kFreeBitmapBlocks;

    sb_.dataBlockStart = sb_.freeBitmapStart + sb_.freeBitmapBlocks;
    sb_.dataBlockCount = sb_.totalBlocks - sb_.dataBlockStart;
}
```

---

### 第15页：块缓存接入点（读写块路径上做 LRU）
- **readBlock**：先 `cache_.get`，miss 再读盘并 `put`
- **writeBlock**：写盘后 `put`，让后续读命中

```225:277:/Volumes/External/Code/OsFinalProject/src/server/filesystem/vfs.cpp
std::vector<std::byte> Vfs::readBlock(std::uint32_t blockId)
{
    bool hit = false;
    auto data = cache_.get(blockId, hit);
    if (hit)
    {
        return data;
    }

    data.assign(sb_.blockSize, std::byte{0});
    const auto offset =
        static_cast<std::streamoff>(blockId) * static_cast<std::streamoff>(sb_.blockSize);
    file_.seekg(offset, std::ios::beg);
    file_.read(reinterpret_cast<char*>(data.data()),
               static_cast<std::streamsize>(data.size()));

    cache_.put(blockId, data);
    return data;
}

bool Vfs::writeBlock(std::uint32_t blockId, const std::vector<std::byte>& data)
{
    const auto offset =
        static_cast<std::streamoff>(blockId) * static_cast<std::streamoff>(sb_.blockSize);
    file_.seekp(offset, std::ios::beg);
    file_.write(reinterpret_cast<const char*>(data.data()),
                static_cast<std::streamsize>(data.size()));
    file_.flush();

    cache_.put(blockId, data);
    return true;
}
```

---

### 第16页：备份与恢复（快照式：复制 data.fs）
- **BACKUP**：先 `vfs_.sync()` 再 `copy_file("data.fs", dst)`
- **RESTORE**：双锁保护（VFS + Auth），`remount()` 后 `loadUsers()`

```236:325:/Volumes/External/Code/OsFinalProject/src/server/handlers/admin_handler.cpp
if (cmd.name == "BACKUP")
{
    // ... auth/role checks ...
    const std::string& dstPath = cmd.args[0];

    {
        std::lock_guard<std::mutex> lock(vfsMutex_);
        if (!vfs_.sync())
        {
            return osp::protocol::makeErrorResponse("FS_ERROR", "BACKUP failed: cannot sync VFS");
        }
    }

    namespace fs = std::filesystem;
    fs::copy_file("data.fs", dstPath, fs::copy_options::overwrite_existing);

    return osp::protocol::makeSuccessResponse({{"message", "Backup completed"}, {"path", dstPath}});
}

if (cmd.name == "RESTORE")
{
    // ... auth/role checks ...
    const std::string& srcPath = cmd.args[0];

    bool ok = false;
    {
        std::scoped_lock lock(vfsMutex_, authMutex_);

        ok = vfs_.remount([&](const std::string& backingFile) -> bool {
            namespace fs = std::filesystem;
            fs::copy_file(srcPath, backingFile, fs::copy_options::overwrite_existing);
            return true;
        });

        auth_.loadUsers();
    }

    return osp::protocol::makeSuccessResponse({{"message", "Restore completed"}, {"path", srcPath}});
}
```

---

### 第17页：系统状态观测（缓存统计 + 业务计数）
- **输出**：users/sessions/papers/reviews + blockCache 统计
- **用于汇报**：直接配合 Web 的 `VIEW_SYSTEM_STATUS` 截图

```328:418:/Volumes/External/Code/OsFinalProject/src/server/handlers/admin_handler.cpp
// VIEW_SYSTEM_STATUS
if (!maybeSession)
{
    return osp::protocol::makeErrorResponse("AUTH_REQUIRED", "VIEW_SYSTEM_STATUS: need to login first");
}
if (maybeSession->role != osp::Role::Admin && maybeSession->role != osp::Role::Editor)
{
    return osp::protocol::makeErrorResponse("PERMISSION_DENIED", "VIEW_SYSTEM_STATUS: permission denied");
}

osp::fs::BlockCache::Stats cs;
{
    std::lock_guard<std::mutex> lock(vfsMutex_);
    cs = vfs_.cacheStats();
}

json data;
data["users"]    = userCount;
data["sessions"] = sessionCount;
data["papers"]   = paperCount;
data["reviews"]  = reviewCount;
data["blockCache"] = {{"capacity", cs.capacity},
                      {"entries", cs.entries},
                      {"hits", cs.hits},
                      {"misses", cs.misses},
                      {"replacements", cs.replacements}};

return osp::protocol::makeSuccessResponse(data);
```

---

如果你希望我把这 17 页进一步“压缩成 15 页版本”（合并两页），我可以按你们老师偏好把 **协议（4–6）合并** 或把 **FS（13–15）合并**。